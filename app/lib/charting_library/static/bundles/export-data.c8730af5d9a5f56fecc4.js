webpackJsonp([26], { 821: function (e, t, i) {
  function n(e, t) { let i; let n; let o; let d; let f; let h; let m; let g; let v; let w; let O; let b; let P; let x; let N; let T; let y; let S; let j; let I; let _; let R; let k; let B; for (void 0 === t && (t = {}), n = { ...p, ...t }, o = { schema: [], data: [] }, d = e.timeScale().points(), f = e.mainSeries(), h = c(e, n.includedStudies), m = l(d, [f.bars()], n.from, n.to), g = m.firstBar(), v = m.lastBar(), n.includeTime && o.schema.push({ type: 'time' }), w = o.schema.length, n.includeSeries && (o.schema.push(r('open')), o.schema.push(r('high')), o.schema.push(r('low')), o.schema.push(r('close'))), O = o.schema.length, b = [], P = 0, x = h; P < x.length; P++)N = x[P], T = s(N), b.push(T), (i = o.schema).push.apply(i, T.fields); if ((y = o.schema.length) === 0) return o; for (S = g; S <= v; ++S)j = new Float64Array(y), j.fill(NaN), o.data.push(j); if (n.includeTime) for (S = g; S <= v; ++S)o.data[S - g][0] = Object(u.ensureNotNull)(d.valueAt(S)); for (n.includeSeries && (I = f.bars().range(g, v), I.each((e, t) => { const i = o.data[e - g]; return i[w] = a(t[1]), i[w + 1] = a(t[2]), i[w + 2] = a(t[3]), i[w + 3] = a(t[4]), !1; })), _ = 0; _ < h.length; ++_) { for (N = h[_], R = b[_], k = function (e) { const t = R.fieldPlotOffsets[e]; const i = R.fieldToPlotIndex[e]; const n = g - t; const l = v - t; const s = O + e; N.data().range(n, l).each((e, t) => { return o.data[e - n][s] = a(t[i]), !1; }); }, B = 0; B < R.fields.length; ++B)k(B); O += R.fields.length; } return o; } function l(e, t, i, n) { let l; let s; let o; let r; let a; const c = Object(u.ensureNotNull)(void 0 !== i ? e.indexOf(i, !0) : e.firstIndex()); const h = Object(u.ensureNotNull)(void 0 !== n ? e.indexOf(n, !0) : e.lastIndex()); let p = h; let m = c; for (l = 0, s = t; l < s.length; l++)o = s[l], r = o.search(c, f.PlotRowSearchMode.NearestRight), r !== null && r.index < p && (p = r.index), (a = o.search(h, f.PlotRowSearchMode.NearestLeft)) !== null && a.index > m && (m = a.index); return Object(u.assert)(p <= m, 'Range must contain at least 1 time point'), new d.BarsRange(p, m); } function s(e) { let t; let i; let n; let l; let s; const r = e.metaInfo(); const a = { fieldToPlotIndex: [], fieldPlotOffsets: [], fields: [] }; const c = e.id(); const u = e.title(!1, void 0, !1); for (t = 0; t < r.plots.length; ++t) { if (i = r.plots[t], n = void 0, l = '', Object(h.isLinePlot)(i))n = r.styles[i.id]; else if (Object(h.isOhlcPlot)(i)) switch (n = r.ohlcPlots && r.ohlcPlots[i.target], i.type) { case 'ohlc_open': l = ` (${window.t('Open')})`; break; case 'ohlc_high': l = ` (${window.t('High')}`; break; case 'ohlc_low': l = ` (${window.t('Low')})`; break; case 'ohlc_close': l = ` (${window.t('Close')})`; } void 0 === n || n.isHidden || void 0 === n.title || (s = `${n.title}${l}`, a.fields.push(o(c, u, s)), a.fieldToPlotIndex.push(t + 1), a.fieldPlotOffsets.push(e.offset(i.id))); } return a; } function o(e, t, i) { return { type: 'value', sourceType: 'study', sourceId: e, sourceTitle: t, plotTitle: i }; } function r(e) { return { type: 'value', sourceType: 'series', plotTitle: e }; } function a(e) { return e != null ? e : NaN; } function c(e, t) { const i = e.allStudies().filter((e) => { return e.showInObjectTree(); }); return t === 'all' ? i : i.filter((e) => { return t.includes(e.id()); }); } let u; let d; let f; let h; let p; Object.defineProperty(t, '__esModule', { value: !0 }), t.exportData = n, i(11), u = i(7), i.n(u), d = i(214), f = i(17), h = i(87), p = { includeTime: !0, includeSeries: !0, includedStudies: 'all' };
} });
